#include <Servo.h>

/*
지금까지 로봇을 코딩하면서 굉장히 불편했을것이다.
추측하건대
1. 모터는 서로 비슷하고 쓰는 함수도 같지만 이름이 달라 연관성이 없어 보임
2. 두 개 이상의 모터를 동시에 움직이고 싶음
3. 코드가 장난아니게 많음
세 가지가 가장 불편했을 것이다.
저 문제들을 해결해 볼 것이다
*/

/*
물건을 정리할때 비슷한 것을 서랍장에 모아놓거나
연관있는 책들을 순서대로 책장에 꽂는것 처럼
프로그래밍을 할때도 비슷한 것을 순서를 부여해 관리하면 편할 것이다
대부분의 프로그래밍 언어에서 이같은 기능을 지원하고 아두이노도 지원한다
아두이노에서 배열은 같은 타입을 가진 원소를 순서를 부여해 모은 것이다
*/

/*
아두이노에서 배열은 다음과 같이 정의한다
int a[2]; //원소가 두개인 원소
float b[3];
Servo motor[8];

일반화해
(원소의 형) (배열 이름)[원소의 개수]로 정의 할 수 있다

초기값을 설정하고 싶을때에는
int a[2]={1,2} 다음과 같이 중괄호 안에 원소를 넣어 설정할 수 있다.
*/

/*
2차원 배열은 배열안에 배열이 들어간 것으로 생각할 수 있다
정의법은 다음과 같다
int a[2][3]; -> {{1,2,3},{4,5,6}} 과 같은 형태
float b[3][4];
Servo motor[8][2];
*/

/*
배열의 접근
배열의 가장 큰 특징 중 하나는 원소의 순서가 있다는 점이다
배열의 원소에 접근하려면 순서를 알아야한다
int a[10]={10,9,8,7,6,5,4,3,2,1}을 생각해보자
첫번째 원소는 10, 두번째 원소는 9, .... , 마지막(열번째)원소는 1이다
위 문장은 인간의 관점에서 바라본 것이다.

프로그래밍 언어에서는 순서를 셀때 0부터 센다
따라서 사실 컴퓨터 입장에서 바라보면
0번째 원소는 10, 1번째 원소는 9, ......, 마지막(9번째)원소는 1이다

배열의 순서를 인덱스라고 하며
배열의 원소에 접근할때는
(배열이름)[인덱스] 형식으로 접근한다
a에서 5를 보고 싶다면
5는 5의 인덱스를 가지므로( = 컴퓨터입장에서 5번째 원소이므로)
a[5]로 접근하는 것이다.
*/

//이제 모터8개를 배열을 이용해 관리해보자

/* 이 그림을 기준으로 관리해보자

   (모터주소, 연결핀)
   __________ __________ _________________
  |(4,8)__(0,4)              (3,7) _(7,11)|
  |__|       |       ^        |        |__|
             |       앞       |
             |                |
             |                |
   _________ |                | __________
  |(5,9)__(1,5)__            (2,6)__(6,10)|
  |__|                                 |__|

*/

//예제1 8개의 Servo형 원소를 가진 배열 motor를 생성하자
//Servo motor[8];

/*
motor의 원소는 Servo형이므로 Servo내의 함수를 쓸 수 있다
(write(), read(), attach())등등
예시
motor[0].write(90);
*/

void setup(){
  //예제2 for문 하나로 그림에 맞춰 모터 8개를 아두이노와 연결하자
  /*
  for (int i = 0; i < 8; i += 1) {
    motor[i].attach(i + 4);
  }
  */
}

void loop(){
  //1번 문제는 배열을 사용함으로 얼추 해결되었다
  /*
  2번문제의 해결
  사실 아두이노로 완벽히 동시에 두 개이상의 서로 다른 모터를 움직일 수 없다
  그러나 동시에 움직이는 것 처럼 보이게 할 수 있다.
  어떻게?
  */

  //예시1 다음 코드를 실행해보자 모터가 움직였는지 구분할 수 있는가?
  /*
  motor[0].write(0);
  motor[0].write(1);
  */

  /*
  아두이노의 계산은 매우 빠른 속도로 이루어져 1도 차이는 구분할 수 없다
  사실 앞에서 delay()를 넣은 이유도 계산이 빠르기 때문이었다
  */

  //예시2 다음 코드를 실행해보자 모터가 어떻게 움직이는지 잘 살펴보자

  /*
  for(int i=0;i<=180;i+=1){
    motor[0].write(i);
    motor[1].write(i);
    motor[2].write(i);
    motor[3].write(i);
  }
  */

  /*
  1도씩 움직이면 동시에 움직이는 것 처럼 보인다!
  */

}




































































































