#include <Servo.h>

/*
지금까지 로봇을 코딩하면서 굉장히 불편했을것이다.
추측하건대
1. 모터는 서로 비슷하고 쓰는 함수도 같지만 이름이 달라 연관성이 없어 보임
2. 두 개 이상의 모터를 동시에 움직이고 싶음
3. 코드가 장난아니게 많음
세 가지가 가장 불편했을 것이다.
저 문제들을 해결해 볼 것이다
*/

/*
물건을 정리할때 비슷한 것을 서랍장에 모아놓거나
연관있는 책들을 순서대로 책장에 꽂는것 처럼
프로그래밍을 할때도 비슷한 것을 순서를 부여해 관리하면 편할 것이다
대부분의 프로그래밍 언어에서 이같은 기능을 지원하고 아두이노도 지원한다
아두이노에서 배열은 같은 타입을 가진 원소를 순서를 부여해 모은 것이다
*/

/*
아두이노에서 배열은 다음과 같이 정의한다
int a[2]; //원소가 두개인 원소
float b[3];
Servo motor[8];

일반화해
(원소의 형) (배열 이름)[원소의 개수]로 정의 할 수 있다

초기값을 설정하고 싶을때에는
int a[2]={1,2} 다음과 같이 중괄호 안에 원소를 넣어 설정할 수 있다.
*/

/*
2차원 배열은 배열안에 배열이 들어간 것으로 생각할 수 있다
정의법은 다음과 같다
int a[2][3]; -> {{1,2,3},{4,5,6}} 과 같은 형태
float b[3][4];
Servo motor[8][2];
*/

/*
배열의 접근
배열의 가장 큰 특징 중 하나는 원소의 순서가 있다는 점이다
배열의 원소에 접근하려면 순서를 알아야한다
int a[10]={10,9,8,7,6,5,4,3,2,1}을 생각해보자
첫번째 원소는 10, 두번째 원소는 9, .... , 마지막(열번째)원소는 1이다
위 문장은 인간의 관점에서 바라본 것이다.

프로그래밍 언어에서는 순서를 셀때 0부터 센다
따라서 사실 컴퓨터 입장에서 바라보면
0번째 원소는 10, 1번째 원소는 9, ......, 마지막(9번째)원소는 1이다

배열의 순서를 인덱스라고 하며
배열의 원소에 접근할때는
(배열이름)[인덱스] 형식으로 접근한다
a에서 5를 보고 싶다면
5는 5의 인덱스를 가지므로( = 컴퓨터입장에서 5번째 원소이므로)
a[5]로 접근하는 것이다.
*/

//이제 모터8개를 배열을 이용해 관리해보자

/* 이 그림을 기준으로 관리해보자

   (모터주소, 연결핀)
   __________ __________ _________________
  |(4,8)__(0,4)              (3,7) _(7,11)|
  |__|       |       ^        |        |__|
             |       앞       |
             |                |
             |                |
   _________ |                | __________
  |(5,9)__(1,5)__            (2,6)__(6,10)|
  |__|                                 |__|

*/

//예제1 8개의 Servo형 원소를 가진 배열 motor를 생성하자
//Servo motor[8];

/*
motor의 원소는 Servo형이므로 Servo내의 함수를 쓸 수 있다
(write(), read(), attach())등등
예시
motor[0].write(90);
*/

void setup(){
  //예제2 for문 하나로 그림에 맞춰 모터 8개를 아두이노와 연결하자
  /*
  for (int i = 0; i < 8; i += 1) {
    motor[i].attach(i + 4);
  }
  */
}
void loop(){
  //1번 문제는 배열을 사용함으로 얼추 해결되었다
  /*
  2번문제의 해결
  사실 아두이노로 완벽히 동시에 두 개이상의 서로 다른 모터를 움직일 수 없다
  그러나 동시에 움직이는 것 처럼 보이게 할 수 있다.
  어떻게?
  */

  //예시1 다음 코드를 실행해보자 모터가 움직였는지 구분할 수 있는가?
  /*
  motor[0].write(0);
  motor[0].write(1);
  */

  /*
  아두이노의 계산은 매우 빠른 속도로 이루어져 1도 차이는 구분할 수 없다
  사실 앞에서 delay()를 넣은 이유도 계산이 빠르기 때문이었다
  */

  //예시2 다음 코드를 실행해보자 모터가 어떻게 움직이는지 잘 살펴보자

  /*
  for(int i=0;i<=180;i+=1){
    motor[0].write(i);
    motor[1].write(i);
    motor[2].write(i);
    motor[3].write(i);
  }
  */

  /*
  1도씩 움직이면 동시에 움직이는 것처럼 보인다!
  이제 우리는 움직이고픈 모터를 같은 반복문에 넣고 1도씩 돌리면
  동시에 움직이는것처럼 보임을 알았다
  */

  /*
  하지만 아직 생각해야할 부분이 남았다
  몇번 모터를 원하는 각도로 어떻게 움직일 것인가?
  우리의 목표는 모터 여러 개도 동시에 돌릴 수 있는 함수이다.
  동시에 돌리려면 한 반복문안에 넣고 1도씩 돌려야함을 위에서 확인했다.
  남은 것은 목표 각도를 프로그램으로 어떻게 표현할 것인가다
  */

  /*
  발상 1
  필자가 생각한 방법이다
  읽어보고 쓸만한 방법인지 스스로 평가해보라

  모터도 배열로 관리하니까 목표각도도 배열로 관리하면 되지않을까?
  모터가 8개니까
  int angle[8] = { 10,20,30,40,50,60,70,80 };
  void move_arr(angle, speed);
  이런 형식으로 함수를 하나 만들면 제어가 편해질 것이다.
  밑 move_arr()함수부분에서 이어가겠다
  아두이노에서는 배열도 함수에 넘겨줄 수 있다
  */

  /*
  이왕 배열쓰는김에 자주쓰는 각도도 배열로 관리해보자
  로봇을 쓰다보면 모터가 어디까지 움직일 수 있는지 즉 각도의 최대, 최소값이 필요한 경우가 많다
  앞으로 걸을때도 앞쪽 방향이 어디인지, 다른 다리와 부딫히지 않는지 확인도 해야한다
  방향과 한계를 미리 조사하여 배열에 넣으면 편할것이다
  이 배열은 전역변수여야 모든 함수에서 사용가능하므로 밑 limit[8][2]에서 서술하겠다
  */

  /*
  이제 move_arr를 정의했으니 각도만 정해주면 그리로 갈것이다
  다음은 그 예시인 앉았다 서기이다
  lay(), stand()함수에서 서술하겠다
  */

  /*
  더 필요한 부분이 있다면 spider.ino를 분석해보라
  */

  심화 문제
  지금까지 배운 내용을 활용해 로봇을 걷게하자
}

/*
필자가 미리 조사한 한계값이다
저장 규칙은 다음과 같다
limit[위치][모드] = {{앞쪽/서는방향한계, 뒤쪽/눕는방향한계}, ...}
이제 이거만 보면 몇번의 각도가 앞쪽인지 뒤쪽인지 쉽게 알 수 있다.
*/
const int limit[8][2] =  { { 0, 160 }, { 10, 170 }, { 170, 10 }, { 170, 30 }, 
                           { 130, 30 }, { 45, 130 }, { 120, 50 }, { 45, 130 }};
//const는 상수란 뜻이다 const값들을 바꾸려하면 에러가 난다 이런 값들은 바뀌면 안되므로 붙인다.
//속도
const int speed = 500;

//아래와 같이 (자료형) (이름)[]을 입력에 넣으면 배열 매개변수로 인식된다
void move_arr(int angle[], int speed){
  /*
  확인배열 정의
  bool check[8] = { false, false, false, false, false, false, false, false };
  모터가 목표 각도일때까지 반복할 것이므로 while문을 쓰자
  8개 다 목표각도이면 while을 빠져나올것이다
  while(!(check[0] && check[1] && check[2] && check[3]
        && check[4] && check[5] && check[6] && check[7])){
    모터 8개 다 움직일 것이므로 반복문을 쓰자
    for (int i = 0; i < 8; i += 1) {
      모터의 현재각도에서 목표각도로 가야하므로 현재 각도를 읽어야한다
      int temp = motor[i].read();
      1도씩 움직이면서 목표각도로 향하려면?
      현재각도가 목표각도보다 크면 1빼고 작으면 1더하면된다
      같으면 check해주자
      if      (temp > arr[i]) motor[i].write(temp - 1);
      else if (temp < arr[i]) motor[i].write(temp + 1);
      else    check[i] = true;
      //마이크로초단위로 지연할 수 있어 좀더 부드럽게 될것이다.
      delayMicroseconds(speed);
  */
}
void lay(int speed) {
  /*
  앉았다 서는건 다리는 가만히 있고 발만 움직이므로 목표배열을 다음과 같이 넣었다.
  int temp[8] = { motor[0].read(), motor[1].read(), motor[2].read(), motor[3].read(),
                  limit[4][1], limit[5][1], limit[6][1], limit[7][1] };
  move_arr(temp, speed);
  */
}
void stand(int speed) {
  /* 서는함수
  int temp[8] = { motor[0].read(), motor[1].read(), motor[2].read(), motor[3].read(),
                  limit[4][0], limit[5][0], limit[6][0], limit[7][0] };
  move_arr(temp, speed);
  */
}



































































































